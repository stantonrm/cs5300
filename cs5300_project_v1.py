# -*- coding: utf-8 -*-
"""cs5300_project_v1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ms6gTeZKf6R4VNSlqz_XCa1EVA9Lp8rp
"""

from keras.models import Sequential
from keras.layers import Dense
import numpy as np
import matplotlib.pyplot as plt

from google.colab import files
uploaded = files.upload()

import numpy as np
dataset = np.loadtxt('movie_metadata_super_clean_usa.csv', skiprows = 1,  delimiter=',')

print('')
print(dataset.shape)
print('')
print(dataset[0:5])

print(np.max(dataset[:, 3]))
print(np.min(dataset[:, 3]))

np.random.shuffle(dataset)
print(dataset[0:5])

"""# Split data set into training and validation sets"""

trainset = dataset[:2000]
validset = dataset[2000:]
print(trainset.shape)
print('')
print(validset.shape)

plt.figure(figsize=(4,4))
plt.plot(trainset[:, 0], trainset[:, 3], '.')
plt.xlabel('1st feature - budget')
plt.ylabel('gross revenue')
plt.show()

plt.figure(figsize=(4,4))
plt.plot(trainset[:, 1], trainset[:, 3], '.')
plt.xlabel('2nd feature - Content Rating')
plt.ylabel('gross revenue')
plt.show()

plt.figure(figsize=(4,4))
plt.plot(trainset[:, 2], trainset[:, 3], '.')
plt.xlabel('3nd feature - Duration')
plt.ylabel('gross revenue')
plt.show()

"""# **Separate Sets into Input and Output Sets**"""

trainset_input = trainset[:, 0:3]
trainset_output = trainset[:, 3:]
validset_input = validset[:, 0:3]
validset_output = validset[:, 3:]
print(trainset_input.shape)
print(trainset_output.shape)
print(validset_input.shape)
print(validset_output.shape)

"""# *Supposed to be a normalization step here.  I GET NAN WITHOUT THIS STEP*"""

trainset_input2 = trainset_input
mean = trainset_input.mean(axis=0)
trainset_input2 -= mean
std = trainset_input.std(axis=0)
trainset_input2 /= std

validset_input2 = validset_input

validset_input2 -= mean
validset_input2 /= std

#mean = trainset_output.mean(axis=0)
#trainset_output -= mean
#std = trainset_output.std(axis=0)
#trainset_output /= std

#validset_output -= mean
#validset_output /= std

"""# Build a model"""

model = Sequential()
model.add(Dense(1, input_dim = 3, activation='linear'))
print(model.summary())
model.compile(loss='mse', optimizer='sgd', metrics=['mae'])
# Verbose = 0 shows no updates, can be changed to 1 or 2
history = model.fit(trainset_input2, trainset_output, epochs= 10, verbose = 1, batch_size=1, validation_data = (validset_input2, validset_output))

"""# Evaluate the predictions"""

prediction = model.predict(validset_input)
print(validset_output[0:5])
print('')
print(prediction[0:5])

plt.figure(figsize=(4,4))
plt.plot(prediction, validset_output, '.')
plt.xlabel('Predictions')
plt.ylabel('Correct values')
plt.show()

results = model.evaluate(validset_input, validset_output)
print ('mae = ', results[1])

print('Model weights (w0, w1, w2 and bias):')
w0 = model.layers[0].get_weights()[0][0]
w1 = model.layers[0].get_weights()[0][1]
w2 = model.layers[0].get_weights()[0][2]
b0 = model.layers[0].get_weights()[1]
print(w0)
print(w1)
print(w2)
print(b0)

print('Validation Data 0:')
print(validset_input[0], validset_output[0])
print('Prediction:')
print(validset_input[0, 0] * (w0) + validset_input[0, 1] * (w1) + validset_input[0, 2] * (w2) + (b0))
print('Validation Data 1:')
print(validset_input[1], validset_output[1])
print('Prediction:')
print(validset_input[1, 0] * (w0) + validset_input[1, 1] * (w1) + validset_input[1, 2] * (w2) + (b0))

"""## Let's design a bigger and more powerful model (NEED HELP WITH THIS)"""

model = Sequential()
model.add(Dense(32, input_dim = 3, activation='sigmoid'))
model.add(Dense(1, activation='linear'))
print(model.summary())
model.compile(loss='mse', optimizer='sgd', metrics=['mae'])
# Verbose = 0 shows no updates, can be changed to 1 or 2
history = model.fit(trainset_input, trainset_output, epochs= 50, verbose = 1, batch_size=128, validation_data = (validset_input, validset_output))

prediction = model.predict(validset_input)
print(validset_output[0:5])
print('')
print(prediction[0:5])

plt.figure(figsize=(4,4))
plt.plot(prediction, validset_output, '.')
plt.xlabel('Predictions')
plt.ylabel('Correct values')
plt.show()

results = model.evaluate(validset_input, validset_output)
print ('mae = ', results[1])